{"version":3,"file":"main.js","sources":["../node_modules/naiv/src/global.ts","../node_modules/naiv/src/reactivity/update.ts","../node_modules/naiv/src/reactivity/clean.ts","../node_modules/naiv/src/reactivity/observable.ts","../node_modules/naiv/src/reactivity/watch.ts","../node_modules/naiv/src/template/cache.ts","../node_modules/naiv/src/template/html.ts","../node_modules/naiv/src/template/map.ts","../node_modules/naiv/src/template/lis.ts","../src/docs/main.ts"],"sourcesContent":["import { Target } from './reactivity/observable'\r\nimport { Update } from './reactivity/update'\r\nimport { Cache } from './template/cache'\r\nimport { MapData } from './template/map'\r\n\r\nconst G = {\r\n  _targets: null as Set<Target>,\r\n  _updates: null as Set<Update>,\r\n  _mapDatas: null as Set<MapData>\r\n}\r\n\r\nconst TARGET_QUEUE = new Set<Target>()\r\nconst UPDATE_QUEUE = new Set<Update>()\r\n\r\nconst CACHES = new Map<string, Cache>()\r\nconst ANCHOR = '!n@a#i$v%'\r\nconst ANCHOR_COMMENT = `<!--${ANCHOR}-->`\r\n\r\nexport {\r\n  G,\r\n  TARGET_QUEUE,\r\n  UPDATE_QUEUE,\r\n  CACHES,\r\n  ANCHOR,\r\n  ANCHOR_COMMENT\r\n}\r\n","import { G } from '../global'\r\nimport { Target } from './observable'\r\n\r\ntype Update = {\r\n  readonly _callback: () => void\r\n  _targets: Set<Target>\r\n  _partialTrack?: true\r\n}\r\n\r\nconst runUpdate = (update: Update) => {\r\n  if (update._partialTrack) {\r\n    update._callback()\r\n  } else {\r\n    const prevTargets = G._targets\r\n    G._targets = new Set()\r\n\r\n    update._callback()\r\n\r\n    for (const e of update._targets) {\r\n      if (!G._targets.has(e))\r\n        e._updates.delete(update)\r\n    }\r\n\r\n    for (const e of G._targets)\r\n      e._updates.add(update)\r\n\r\n    update._targets = G._targets\r\n    G._targets = prevTargets\r\n  }\r\n}\r\n\r\nexport {\r\n  Update,\r\n  runUpdate\r\n}\r\n","import { TARGET_QUEUE, UPDATE_QUEUE, G } from '../global'\r\nimport { runUpdate } from './update'\r\n\r\nlet IS_ENTRY = true\r\n\r\nconst queueUpdates = () => {\r\n  for (const target of TARGET_QUEUE) {\r\n    for (const e of target._updates)\r\n      UPDATE_QUEUE.add(e)\r\n  }\r\n\r\n  TARGET_QUEUE.clear()\r\n}\r\n\r\nconst clean = () => {\r\n  if (IS_ENTRY && !G._targets) {\r\n    IS_ENTRY = false\r\n\r\n    queueUpdates()\r\n    for (const e of UPDATE_QUEUE) {\r\n      UPDATE_QUEUE.delete(e)\r\n      runUpdate(e)\r\n      queueUpdates()\r\n    }\r\n\r\n    IS_ENTRY = true\r\n  }\r\n}\r\n\r\nexport {\r\n  clean\r\n}\r\n","import { G, TARGET_QUEUE } from '../global'\r\nimport { Update } from './update'\r\nimport { clean } from './clean'\r\n\r\nconst TARGET = Symbol()\r\n\r\ntype Target = {\r\n  ()\r\n  _value: any\r\n  readonly _updates: Set<Update>\r\n}\r\n\r\ntype Observable = {\r\n  (value?)\r\n  readonly [TARGET]: Target\r\n  [prop: string]: any\r\n}\r\n\r\nconst observable = (value?) => {\r\n  const target = () => {}\r\n  target._value = value\r\n  target._updates = new Set()\r\n  return new Proxy(target, HANDLER) as unknown as Observable\r\n}\r\n\r\nconst HANDLER: ProxyHandler<Target> = {\r\n  apply (target, _this, args: any[]) {\r\n    if (args.length) {\r\n      if (target._value !== args[0]) {\r\n        target._value = args[0]\r\n        TARGET_QUEUE.add(target)\r\n        clean()\r\n      }\r\n    } else {\r\n      G._targets && G._targets.add(target)\r\n      return target._value\r\n    }\r\n  },\r\n  get: (target, prop) => {\r\n    if (prop === TARGET) return target\r\n    G._targets && G._targets.add(target)\r\n\r\n    const item = target._value[prop]\r\n    return typeof item === 'function' && !item[TARGET]\r\n      ? item.bind(target._value)\r\n      : item\r\n  },\r\n  set: (target, prop, value) => {\r\n    if (target._value[prop] !== value) {\r\n      target._value[prop] = value\r\n      TARGET_QUEUE.add(target)\r\n      clean()\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nconst trigger = (obs: Observable) => {\r\n  TARGET_QUEUE.add(obs[TARGET])\r\n  clean()\r\n}\r\n\r\nexport {\r\n  Target,\r\n  Observable,\r\n  TARGET,\r\n  observable,\r\n  trigger\r\n}\r\n","import { G } from '../global'\r\nimport { Observable, TARGET } from './observable'\r\nimport { Update, runUpdate } from './update'\r\nimport { clean } from './clean'\r\n\r\nconst watch = (\r\n  callback: () => void,\r\n  ...observables: Observable[]\r\n) => {\r\n  const update: Update = {\r\n    _callback: callback,\r\n    _targets: new Set()\r\n  }\r\n\r\n  if (observables.length) {\r\n    update._partialTrack = true\r\n\r\n    for (const e of observables) {\r\n      const target = e[TARGET]\r\n      target._updates.add(update)\r\n      update._targets.add(target)\r\n    }\r\n  }\r\n\r\n  if (G._updates)\r\n    G._updates.add(update)\r\n\r\n  runUpdate(update)\r\n  clean()\r\n}\r\n\r\nexport {\r\n  watch\r\n}\r\n","import { ANCHOR } from '../global'\r\n\r\ntype Cache = {\r\n  readonly _proto: DocumentFragment\r\n  readonly _exprs: Array<{\r\n    _path: number[]\r\n    _attrs?: string[]\r\n  }>\r\n}\r\n\r\nconst isCommentAnchor = (node: Node) => {\r\n  return node && node.nodeType === 8 && node.nodeValue === ANCHOR\r\n}\r\n\r\nconst parseCache = (\r\n  cache: Cache,\r\n  parent: Node = cache._proto,\r\n  path: number[] = []\r\n) => {\r\n  for (let i = 0; i < parent.childNodes.length; ++i) {\r\n    const node = parent.childNodes[i]\r\n    const type = node.nodeType\r\n\r\n    // text\r\n    if (type === 3) {\r\n      let value = node.nodeValue\r\n\r\n      if (!isCommentAnchor(node.previousSibling))\r\n        value = value.trimStart()\r\n      if (!isCommentAnchor(node.nextSibling))\r\n        value = value.trimEnd()\r\n\r\n      if (value) {\r\n        const texts = value.split(ANCHOR)\r\n        --i\r\n\r\n        for (let j = 0; ; ++j) {\r\n          // static text\r\n          const text = texts[j].replace(/\\s+/, ' ')\r\n          if (text) {\r\n            node.before(document.createTextNode(text))\r\n            i += 2\r\n          } else {\r\n            i += 1\r\n          }\r\n\r\n          // skip the last static text\r\n          if (j === texts.length - 1) break\r\n\r\n          // add anchor refs\r\n          node.before(document.createComment(''))\r\n          cache._exprs.push({ _path: [...path, i] })\r\n        }\r\n      }\r\n\r\n      // remove the parsed text\r\n      parent.removeChild(node)\r\n      --i\r\n    } else {\r\n      const _path = [...path, i]\r\n\r\n      // element\r\n      if (type === 1) {\r\n        const _attrs = []\r\n\r\n        for (const e of (node as Element).attributes)\r\n          e.value === ANCHOR && _attrs.push(e.name)\r\n\r\n        // add attribute refs\r\n        _attrs.length && cache._exprs.push({ _path, _attrs })\r\n\r\n        // parse children\r\n        parseCache(cache, node, _path)\r\n\r\n      // add comment anchor refs\r\n      } else if (isCommentAnchor(node)) {\r\n        cache._exprs.push({ _path })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  Cache,\r\n  parseCache\r\n}\r\n","import { ANCHOR, ANCHOR_COMMENT, CACHES } from '../global'\r\nimport { parseCache } from './cache'\r\nimport { watch } from '../reactivity/watch'\r\n\r\nconst html = (htmls: TemplateStringsArray, ...exprs: any[]) => {\r\n  // create template string\r\n  let html = ''\r\n  for (let i = 0, last = htmls.length - 1; ; ++i) {\r\n    const s = htmls[i]\r\n    html += s\r\n    if (i === last) break\r\n    html += s.slice(-1) === '='\r\n      ? ANCHOR\r\n      : ANCHOR_COMMENT\r\n  }\r\n\r\n  // get cache or create if not found\r\n  let cache = CACHES.get(html)\r\n  if (!cache) {\r\n    const template = document.createElement('template')\r\n    template.innerHTML = html\r\n    cache = {\r\n      _proto: template.content,\r\n      _exprs: []\r\n    }\r\n    parseCache(cache)\r\n    CACHES.set(html, cache)\r\n  }\r\n\r\n  // clone & set expression values\r\n  const clone = cache._proto.cloneNode(true)\r\n\r\n  for (let i = 0, j = 0; i < cache._exprs.length; ++i) {\r\n    const cachedExpr = cache._exprs[i]\r\n\r\n    // get anchor\r\n    let anchor = clone as ChildNode\r\n    for (const e of cachedExpr._path)\r\n      anchor = anchor.childNodes[e]\r\n\r\n    // element attributes\r\n    if (cachedExpr._attrs) {\r\n      for (const e of cachedExpr._attrs) {\r\n        const expr = exprs[j++]\r\n\r\n        // event\r\n        if (e.substring(0, 2) === 'on') {\r\n          anchor[e] = expr\r\n\r\n        // attribute\r\n        } else {\r\n          if (typeof expr === 'function')\r\n            watch(() => (anchor as Element).setAttribute(e, expr()))\r\n          else\r\n            (anchor as Element).setAttribute(e, expr)\r\n        }\r\n      }\r\n    } else {\r\n      const expr = exprs[j++]\r\n\r\n      // child node\r\n      if (expr instanceof Node) {\r\n        anchor.replaceWith(expr)\r\n      // text\r\n      } else {\r\n        const textNode = document.createTextNode('')\r\n        anchor.replaceWith(textNode)\r\n        if (typeof expr === 'function')\r\n          watch(() => textNode.nodeValue = expr())\r\n        else\r\n          textNode.nodeValue = expr\r\n      }\r\n    }\r\n  }\r\n\r\n  return clone.childNodes[0] || document.createComment('') as Node | Element\r\n}\r\n\r\nexport {\r\n  html\r\n}\r\n","import { G } from '../global'\r\nimport { Update } from '../reactivity/update'\r\nimport { Observable, observable } from '../reactivity/observable'\r\nimport { watch } from '../reactivity/watch'\r\nimport { getLIS } from './lis'\r\n\r\ntype Item = {\r\n  _index: Observable\r\n  _value: Observable\r\n  _node: ChildNode\r\n  _updates: Set<Update>\r\n  _mapDatas: Set<MapData>\r\n}\r\n\r\ntype MapData = {\r\n  _array: Observable\r\n  _root: ParentNode\r\n  _key: Key\r\n  _html: Html\r\n  _items: Map<any, Item>\r\n  _oldKeys: any[]\r\n}\r\n\r\ntype Html = (value?: Observable, index?: Observable) => ChildNode\r\ntype Key = (value?: any, index?: number) => any\r\n\r\nconst map = (\r\n  _array: Observable,\r\n  _key: Key,\r\n  _root: ParentNode,\r\n  _html: Html\r\n) => {\r\n  const data: MapData = {\r\n    _array,\r\n    _key,\r\n    _root,\r\n    _html,\r\n    _items: new Map(),\r\n    _oldKeys: []\r\n  }\r\n\r\n  if (G._mapDatas)\r\n    G._mapDatas.add(data)\r\n\r\n  watch(() => setup(data), _array)\r\n  return _root\r\n}\r\n\r\nconst setup = (m: MapData) => {\r\n  const array = m._array() as any[]\r\n  let oldKeys = m._oldKeys\r\n  let newKeys = []\r\n\r\n  for (let i = 0; i < array.length; ++i) {\r\n    // add new key\r\n    const value = array[i]\r\n    const key = m._key(value, i)\r\n    newKeys.push(key)\r\n\r\n    // udpate item if exist\r\n    const item = m._items.get(key)\r\n    if (item) {\r\n      item._index(i)\r\n      item._value(value)\r\n\r\n    // create new if not\r\n    } else {\r\n      const prevUpdates = G._updates\r\n      const prevMapDatas = G._mapDatas\r\n      G._updates = new Set()\r\n      G._mapDatas = new Set()\r\n\r\n      const _index = observable(i)\r\n      const _value = observable(value)\r\n      const item = {\r\n        _index,\r\n        _value,\r\n        _node: m._html(_value, _index),\r\n        _updates: G._updates,\r\n        _mapDatas: G._mapDatas\r\n      }\r\n\r\n      m._items.set(key, item)\r\n      G._updates = prevUpdates\r\n      G._mapDatas = prevMapDatas\r\n    }\r\n  }\r\n\r\n  // update old keys\r\n  m._oldKeys = newKeys\r\n\r\n  // setup trim\r\n  let oldEnd = oldKeys.length - 1\r\n  let newEnd = array.length - 1\r\n  let end = Math.min(oldEnd, newEnd)\r\n  let start = 0\r\n\r\n  while (start <= end && oldKeys[start] === newKeys[start])\r\n    ++start\r\n  while (end > start && oldKeys[oldEnd] === newKeys[newEnd]) {\r\n    --end\r\n    --oldEnd\r\n    --newEnd\r\n  }\r\n\r\n  // trim\r\n  let prevNode = start\r\n    ? m._items.get(newKeys[start - 1])._node\r\n    : null\r\n  oldKeys = oldKeys.slice(start, oldEnd + 1)\r\n  newKeys = newKeys.slice(start, newEnd + 1)\r\n\r\n  // get longest order\r\n  const order = [] as number[]\r\n\r\n  for (let i = 0; i < oldKeys.length; ++i) {\r\n    const key = oldKeys[i]\r\n    const pos = newKeys.indexOf(key)\r\n\r\n    // remove if not exist in new array\r\n    if (pos < 0) {\r\n      const item = m._items.get(key)\r\n      m._items.delete(key)\r\n\r\n      // stop updates\r\n      stopItemUpdates(item)\r\n\r\n      // remove node\r\n      item._node.remove()\r\n\r\n    // add position if exist\r\n    } else {\r\n      order.push(pos)\r\n    }\r\n  }\r\n\r\n  // longest order\r\n  const lis = getLIS(order)\r\n\r\n  // add/move items\r\n  for (let i = 0; i < newKeys.length; ++i) {\r\n    const item = m._items.get(newKeys[i])\r\n\r\n    if (!lis.includes(i)) {\r\n      if (prevNode) prevNode.after(item._node)\r\n      else m._root.prepend(item._node)\r\n    }\r\n\r\n    prevNode = item._node\r\n  }\r\n}\r\n\r\nconst stopItemUpdates = (item: Item) => {\r\n  // stop nested updates\r\n  for (const update of item._updates) {\r\n    for (const e of update._targets)\r\n      e._updates.delete(update)\r\n  }\r\n\r\n  // stop nested maps\r\n  for (const e of item._mapDatas)\r\n    e._items.forEach(stopItemUpdates)\r\n}\r\n\r\nexport {\r\n  MapData,\r\n  map\r\n}\r\n","// longest increasing unique sequence\r\nconst getLIS = (nums: readonly number[]) => {\r\n  if (!nums.length) return []\r\n  const sequences = [[nums[0]]]\r\n\r\n  for (let i = 1; i < nums.length; ++i) {\r\n    const num = nums[i]\r\n    for (let j = sequences.length - 1; j >= 0; --j) {\r\n      const sequence = sequences[j]\r\n\r\n      if (num < sequence[sequence.length - 1]) {\r\n        if (j) continue\r\n        else sequences.splice(0, 1, [num])\r\n      } else {\r\n        sequences.splice(j + 1, 1, [...sequence, num])\r\n      }\r\n      break\r\n    }\r\n  }\r\n\r\n  return sequences.pop()\r\n}\r\n\r\nexport {\r\n  getLIS\r\n}\r\n","import { observable, html, map } from 'naiv'\r\n\r\nconst Header = html`\r\n<div class='text-center'>\r\n  <span class='text-4xl'>hashnum</span>\r\n  <a class='align-text-bottom ml-3' href='#'>\r\n    <img class='inline h-8' src='GitHub-Mark-64px.png'>\r\n  </a>\r\n</div>\r\n`\r\n\r\nconst nums = observable([12, 23, 445])\r\n\r\nconst InputNums = map(\r\n  nums,\r\n  (e, i) => i,\r\n  html`<div></div>`,\r\n  (e, i) => html`\r\n    <div \r\n      class='px-1 my-1 inline-block'\r\n      \r\n      contenteditable>\r\n      ${e}\r\n    </div>\r\n  `\r\n)\r\n\r\nconst InputContainer = (content = '') => html`\r\n  <div class='\r\n    m-5\r\n    w-5/6 sm:w-4/6 md:w-3/6 lg:w-2/6 h-40\r\n    border-2 bg-white rounded-lg border-black'>\r\n    ${content}\r\n  </div> \r\n`\r\n\r\nconst App = html`\r\n  <div class='flex flex-col font-mono min-h-screen bg-gray-300 '>\r\n    ${Header}\r\n    <div class='my-10 flex flex-col items-center'>\r\n      ${InputContainer(InputNums)}\r\n      ${InputContainer()}\r\n    </div>\r\n  </div>\r\n`\r\n\r\ndocument.body.append(App)\r\n"],"names":["G","t","o","s","TARGET_QUEUE","Set","UPDATE_QUEUE","CACHES","Map","ANCHOR","runUpdate","update","_partialTrack","_callback","prevTargets","_targets","e","has","_updates","delete","add","IS_ENTRY","queueUpdates","target","clear","clean","TARGET","Symbol","observable","value","_value","Proxy","HANDLER","[object Object]","_this","args","length","get","prop","item","bind","set","watch","callback","observables","i","isCommentAnchor","node","nodeType","nodeValue","parseCache","cache","parent","_proto","path","childNodes","type","previousSibling","trimStart","nextSibling","trimEnd","texts","split","j","text","replace","before","document","createTextNode","createComment","_exprs","push","m","removeChild","_path","_attrs","attributes","name","S","html","htmls","exprs","last","slice","template","createElement","innerHTML","_","content","p","clone","cloneNode","cachedExpr","anchor","expr","substring","setAttribute","Node","replaceWith","textNode","setup","array","_array","oldKeys","_oldKeys","newKeys","key","_key","_items","_index","prevUpdates","prevMapDatas","_mapDatas","$","u","K","_html","oldEnd","newEnd","end","Math","min","start","prevNode","_node","order","pos","indexOf","stopItemUpdates","remove","lis","nums","sequences","num","sequence","splice","pop","includes","after","_root","prepend","forEach","Header","InputNums","data","h","k","g","v","M","D","map","InputContainer","App","body","append"],"mappings":"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"}